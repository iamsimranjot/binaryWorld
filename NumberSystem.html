<html>
<body bgcolor=#0B615E text=ivory>

<a name=ns><b><font color=#B45F04 size=6>Numbering System</b></font><br>
<font size=4>
Many number systems are in use in digital technology. The most common are the decimal, binary, octal, and hexadecimal systems. The decimal system is clearly the most familiar to us because it is a tool that we use every day. Examining some of its characteristics will help us to better understand the other systems. In the next few pages we shall introduce four numerical representation systems that are used in the digital system. There are other systems, which we will look at briefly.
<br><pre>
* Decimal
* Binary
* Octal
* Hexadecimal
</pre></font><br>


<b><font color=#B45F04 size=6>Decimal System</b></font><br>
<font size=4>
The decimal system is composed of 10 numerals or symbols. These 10 symbols are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Using these symbols as digits of a number, we can express any quantity. The decimal system is also called the base-10 system because it has 10 digits.
<br><br>
<img src="table1.png">
<br><br>
Even though the decimal system has only 10 symbols, any number of any magnitude can be expressed by using our system of positional weighting.</font>
<br> 	


<b><font color=#B45F04  size=6>Decimal Examples</b></font><br>
<font size=4>
<pre>
* 3.14<sub>10</sub>
* 52<sub>10</sub>
* 1024<sub>10</sub>
* 64000<sub>10</sub>
</pre></font><br>	


<b><font color=#B45F04 size=6>Binary System</b></font><br>
<font size=4>
In the binary system, there are only two symbols or possible digit values, 0 and 1. This base-2 system can be used to represent any quantity that can be represented in decimal or other base system.
<br><br>
<img src="table2.png">
<br>
</font><br>




<b><font color=#B45F04 size=6>Binary Counting</b></font><br><font size=4>	
The Binary counting sequence is shown in the table:
<br><br>
<img src="table3.png">
<br><br>


<b><font color=#B45F04 size=6>Representing Binary Quantities</b></font><br><font size=4>	
In digital systems the information that is being processed is usually presented in binary form. Binary quantities can be represented by any device that has only two operating states or possible conditions. E.g.. a switch is only open or closed. We arbitrarily (as we define them) let an open switch represent binary 0 and a closed switch represent binary 1. Thus we can represent any binary number by using series of switches.</font>
<br>


<b><font color=#B45F04 size=6>	Typical Voltage Assignment</b></font><br><font size=4>	
Binary 1: Any voltage between 2V to 5V
Binary 0: Any voltage between 0V to 0.8V
Not used: Voltage between 0.8V to 2V in 5 Volt CMOS and TTL Logic, this may cause error in a digital circuit. Today's digital circuits works at 1.8 volts, so this statement may not hold true for all logic circuits.
<br><br>
<img src="digital_voltage1.gif">
<br><br>
We can see another significant difference between digital and analog systems. In digital systems, the exact voltage value is not important; eg, a voltage of 3.6V means the same as a voltage of 4.3V. In analog systems, the exact voltage value is important.
The binary number system is the most important one in digital systems, but several others are also important. The decimal system is important because it is universally used to represent quantities outside a digital system. This means that there will be situations where decimal values have to be converted to binary values before they are entered into the digital system.
In additional to binary and decimal, two other number systems find wide-spread applications in digital systems. The octal (base-8) and hexadecimal (base-16) number systems are both used for the same purpose- to provide an efficient means for representing large binary system.
</font>
<br>



<b><font color=#B45F04 size=6>Octal System</b></font><br><font size=4>	
The octal number system has a base of eight, meaning that it has eight possible digits: 0,1,2,3,4,5,6,7.
<br><br>
<img src="table4.png">
<br><br>
</font>


<b><font color=#B45F04 size=6>Octal to Decimal Conversion</b></font><br>
<font size=4>	
<pre>
* 237<sub>8</sub> = 2 x (8<sup>2</sup>) + 3 x (8<sup>1</sup>) + 7 x (8<sup>0</sup>) = 159<sub>10</sub> 
* 24.6<sub>8</sub> = 2 x (8<sup>1</sup>) + 4 x (8<sup>0</sup>) + 6 x (8<sup>-1</sup>) = 20.75<sub>10</sub> 
* 11.1<sub>8</sub> = 1 x (8<sup>1</sup>) + 1 x (8<sup>0</sup>) + 1 x (8<sup>-1</sup>) = 9.125<sub>10</sub> 
* 12.3<sub>8</sub> = 1 x (8<sup>1</sup>) + 2 x (8<sup>0</sup>) + 3 x (8<sup>-1</sup>) = 10.375<sub>10</sub> 
</pre>


<b><font color=#B45F04 size=6>Hexadecimal System </b></font><br>
<font size=4>
The hexadecimal system uses base 16. Thus, it has 16 possible digit symbols. It uses the digits 0 through 9 plus the letters A, B, C, D, E, and F as the 16 digit symbols.
<br><br>
<img src="table5.png">
<br><br>
</font>



<b><font color=#B45F04 size=6>	Hexadecimal to Decimal Conversion</b></font><br>
<pre>
* 24.6<sub>16</sub> = 2 x (16<sup>1</sup>) + 4 x (16<sup>0</sup>) + 6 x (16<sup>-1</sup>) = 36.375<sub>10</sub>
* 11.1<sub>16</sub> = 1 x (16<sup>1</sup>) + 1 x (16<sup>0</sup>) + 1 x (16<sup>-1</sup>) = 17.0625<sub>10</sub>
* 12.3<sub>16</sub> = 1 x (16<sup>1</sup>) + 2 x (16<sup>0</sup>) + 3 x (16<sup>-1</sup>) = 18.1875<sub>10</sub>
</pre>
<br><br><br>


<a name=cc><b><font color=#B45F04 size=6>Code Conversion</b></font><br>
<font size=4>
Converting from one code form to another code form is called code conversion, like converting from binary to decimal or converting from hexadecimal to decimal.
</font>
<br><br>



<b><font color=#B45F04 size=6>Binary-To-Decimal Conversion </b></font><br>
<font size=4>
Any binary number can be converted to its decimal equivalent simply by summing together the weights of the various positions in the binary number which contain a 1.
<br><br>
<img src="table 6.png">
<br><br>
and
<br><br>
<img src="table 7.png">
<br><br>
You should have noticed that the method is to find the weights (i.e., powers of 2) for each bit position that contains a 1, and then to add them up.
</font><br>



<b><font color=#B45F04 size=6>	Decimal-To-Binary Conversion</b></font><br>
<font size=4>
There are 2 methods:
<pre>
* Reverse of Binary-To-Decimal Method
* Repeat Division
</pre><br>

<b><font color=#B45F04 size=6>Reverse of Binary-To-Decimal Method</b></font><br>
<br><br>
<img src="table 8.png">
<br><br>

<b><font color=#B45F04 size=6>Repeat Division-Convert decimal to binary</b></font><br>
This method uses repeated division by 2.
<pre>
* Convert 25<sub>10</sub> to binary
</pre><br><br>
<img src="table 9.png">
<br><br>The Flow chart for repeated-division method is as follows:
<br><br>
<img src="repeat_division.gif">
<br><br>


<b><font color=#B45F04 size=6>Binary-To-Octal / Octal-To-Binary Conversion </b></font><br>
<br><br><img src="table 10.png"><br><br><font size=4>
Each Octal digit is represented by three binary digits.
Example:
<pre>
* 100 111 010<sub>2</sub> = (100) (111) (010)<sub>2</sub> = 4 7 2<sub>8</sub>
</pre>
<br></font>

<b><font color=#B45F04 size=6>Repeat Division-Convert decimal to octal </b></font><br>
<font size=4>
This method uses repeated division by 8
Example: Convert 177<sub>10</sub> to octal and binary
<br><br>
<img src="table 11.png">
<br><br>

<b><font color=#B45F04 size=6>Hexadecimal to Decimal/Decimal to Hexadecimal Conversion</b></font><br><font size=4>
<pre>
Example:
* 2AF<sub>16</sub> = 2 x (16<sup>2</sup>) + 10 x (16<sup>1</sup>) + 15 x (16<sup>0</sup>) = 687<sub>10</sub>
</pre>
<br>

<b><font color=#B45F04 size=6>Repeat Division- Convert decimal to hexadecimal </b></font><br><font size=4>
This method uses repeated division by 16.<br>
Example: convert 378<sub>10</sub> to hexadecimal and binary:
<br><br>
<img src="table 12.png">
<br><br>


<b><font color=#B45F04 size=6>Binary-To-Hexadecimal /Hexadecimal-To-Binary Conversion</b></font><br>
<br><br>
<img src="table 13.png">
<br><br><font size=4>
Each Hexadecimal digit is represented by four bits of binary digit.<br>
Example:<br>* 1011 0010 1111<sub>2</sub> = (1011) (0010) (1111)<sub>2</sub> = B 2 F<sub>16</sub>
<br></font>


<b><font color=#B45F04 size=6>	Octal-To-Hexadecimal Hexadecimal-To-Octal Conversion</b></font><br>
<font size=4><pre>
Convert Octal (Hexadecimal) to Binary first.

* Regroup the binary number by three bits per group starting from LSB if Octal is required.
* Regroup the binary number by four bits per group starting from LSB if Hexadecimal is required.
 	 	
Example:

Convert 5A8<sub>16</sub> to Octal.
 </pre></font>
<img src="table 14.png">
<br><br>







<a name=bc><b><font color=#B45F04 size=6> Binary Codes </b></font><br>
<font size=4>
Binary codes are codes which are represented in binary system with modification from the original ones. Below we will be seeing the following:
<pre>
* Weighted Binary Systems
* Non Weighted Codes
</pre></font>


<b><font color=#B45F04 size=6> 	Weighted Binary Systems </b></font><br>
<font size=4>
Weighted binary codes are those which obey the positional weighting principles, each position of the number represents a specific weight. The binary counting sequence is an example.
<br><br>
<img src="table 15.png">
<br><br></font>

<b><font color=#B45F04 size=6> 	8421 Code/BCD Code </b></font><br><br>
<font size=4>
The BCD (Binary Coded Decimal) is a straight assignment of the binary equivalent. It is possible to assign weights to the binary bits according to their positions. The weights in the BCD code are 8,4,2,1.

Example: The bit assignment 1001, can be seen by its weights to represent the decimal 9 because:
<br>
1x8+0x4+0x2+1x1 = 9
<br><br></font>


<b><font color=#B45F04 size=6>	2421 Code </b></font><br><br>
<font size=4>
This is a weighted code, its weights are 2, 4, 2 and 1. A decimal number is represented in 4-bit form and the total four bits weight is 2 + 4 + 2 + 1 = 9. Hence the 2421 code represents the decimal numbers from 0 to 9.
<br><br></font>



<b><font color=#B45F04 size=6> 5211 Code </b></font><br><br>
<font size=4>
This is a weighted code, its weights are 5, 2, 1 and 1. A decimal number is represented in 4-bit form and the total four bits weight is 5 + 2 + 1 + 1 = 9. Hence the 5211 code represents the decimal numbers from 0 to 9.
<br><br></font>




<b><font color=#B45F04 size=6> Reflective Code </b></font><br>
<br><font size=4>
A code is said to be reflective when code for 9 is complement for the code for 0, and so is for 8 and 1 codes, 7 and 2, 6 and 3, 5 and 4. Codes 2421, 5211, and excess-3 are reflective, whereas the 8421 code is not.
<br><br></font>
 	 	





<b><font color=#B45F04 size=6> 	Sequential Codes </b></font><br><br>
<font size=4>
A code is said to be sequential when two subsequent codes, seen as numbers in binary representation, differ by one. This greatly aids mathematical manipulation of data. The 8421 and Excess-3 codes are sequential, whereas the 2421 and 5211 codes are not.
<br><br></font>






<b><font color=#B45F04 size=6> Non Weighted Codes </b></font><br><br>
<font size=4>
Non weighted codes are codes that are not positionally weighted. That is, each position within the binary number is not assigned a fixed value.
<br><br></font>





<b><font color=#B45F04 size=6> Excess-3 Code </b></font><br><br>
<font size=4>
Excess-3 is a non weighted code used to express decimal numbers. The code derives its name from the fact that each binary code is the corresponding 8421 code plus 0011(3).
<br>
Example: 1000 of 8421 = 1011 in Excess-3
<br><br></font>





<b><font color=#B45F04 size=6>	Gray Code </b></font><br>
<font size=4>
The gray code belongs to a class of codes called minimum change codes, in which only one bit in the code changes when moving from one code to the next. The Gray code is non-weighted code, as the position of bit does not contain any weight. The gray code is a reflective digital code which has the special property that any two subsequent numbers codes differ by only one bit. This is also called a unit-distance code. In digital Gray code has got a special place.
<br></font>
<br><br>
<img src="table 16.png">
<br><br>





 	 	

<b><font color=#B45F04 size=6> Binary to Gray Conversion </b></font><br><br>
<font size=4>
<pre>
* Gray Code MSB is binary code MSB.
* Gray Code MSB-1 is the XOR of binary code MSB and MSB-1.
* MSB-2 bit of gray code is XOR of MSB-1 and MSB-2 bit of binary code.
* MSB-N bit of gray code is XOR of MSB-N-1 and MSB-N bit of binary code.
</pre>






<a name=ed><b><font color=#B45F04 size=6> Error Detecting and Correction Codes </b></font><br><br>
<font size=4>
For reliable transmission and storage of digital data, error detection and correction is required. Below are a few examples of codes which permit error detection and error correction after detection.
<br><br></font>







<b><font color=#B45F04 size=6> 	Error Detecting Codes  </b></font><br><br>
<font size=4>
When data is transmitted from one point to another, like in wireless transmission, or it is just stored, like in hard disks and memories, there are chances that data may get corrupted. To detect these data errors, we use special codes, which are error detection codes.
<br><br></font>



 	 	


<b><font color=#B45F04 size=6> 	Parity </b></font><font size=4><br>
In parity codes, every data byte, or nibble (according to how user wants to use it) is checked if they have even number of ones or even number of zeros. Based on this information an additional bit is appended to the original data. Thus if we consider 8-bit data, adding the parity bit will make it 9 bit long.
At the receiver side, once again parity is calculated and matched with the received parity (bit 9), and if they match, data is ok, otherwise data is corrupt.
There are two types of parity:
<pre>
* <b>Even parity</b>: Checks if there is an even number of ones; if so, parity bit is zero. When the number of ones is odd then parity bit is set to 1.
* <b>Odd Parity</b>: Checks if there is an odd number of ones; if so, parity bit is zero. When number of ones is even then parity bit is set to 1.
<br><br></font>

<b><font color=#B45F04 size=6> Check Sums </b></font><font size=4>
The parity method is calculated over byte, word or double word. But when errors need to be checked over 128 bytes or more (basically blocks of data), then calculating parity is not the right way. So we have checksum, which allows to check for errors on block of data. There are many variations of checksum.
<pre>
* Adding all bytes
* CRC
* Fletcher's checksum
* Adler-32
</pre>
The simplest form of checksum, which simply adds up the asserted bits in the data, cannot detect a number of types of errors. In particular, such a checksum is not changed by:
<pre>
* Reordering of the bytes in the message
* Inserting or deleting zero-valued bytes
* Multiple errors which sum to zero
</pre> 	 	
Example of Checksum : Given 4 bytes of data (can be done with any number of bytes): 25h, 62h, 3Fh, 52h
<pre>
* Adding all bytes together gives 118h.
*  Drop the Carry Nibble to give you 18h.
* Get the two's complement of the 18h to get E8h. This is the checksum byte.
</pre> 	 	
To Test the Checksum byte simply add it to the original group of bytes. This should give you 200h.
Drop the carry nibble again giving 00h. Since it is 00h this means the checksum means the bytes were probably not changed.
<br><br></font>



<b><font color=#B45F04 size=6>Error-Correcting Codes </b></font><font size=4>
Error-correcting codes not only detect errors, but also correct them. This is used normally in Satellite communication, where turn-around delay is very high as is the probability of data getting corrupt.
ECC (Error correcting codes) are used also in memories, networking, Hard disk, CDROM, DVD etc. Normally in networking chips (ASIC), we have 2 Error detection bits and 1 Error correction bit.
<br><br></font>



<b><font color=#B45F04 size=6>Hamming Code</b></font><font size=4>
Hamming code adds a minimum number of bits to the data transmitted in a noisy channel, to be able to correct every possible one-bit error. It can detect (not correct) two-bits errors and cannot distinguish between 1-bit and 2-bits inconsistencies. It can't - in general - detect 3(or more)-bits errors.
The idea is that the failed bit position in an n-bit string (which we'll call X) can be represented in binary with log2(n) bits, hence we'll try to get it adding just log2(n) bits.
First, we set m = n + log2(n) to the encoded string length and we number each bit position starting from 1 through m. Then we place these additional bits at power-of-two positions, that is 1, 2, 4, 8..., while remaining ones (3, 5, 6, 7...) hold the bit string in the original order.
Now we set each added bit to the parity of a group of bits. We group bits this way: we form a group for every parity bit, where the following relation holds:

position(bit) AND position(parity) = position(parity)

(Note that: AND is the bit-wise boolean AND; parity bits are included in the groups; each bit can belong to one or more groups.)

So bit 1 groups bits 1, 3, 5, 7... while bit 2 groups bits 2, 3, 6, 7, 10... , bit 4 groups bits 4, 5, 6, 7, 12, 13... and so on.

Thus, by definition, X (the failed bit position defined above) is the sum of the incorrect parity bits positions (0 for no errors).

To understand why it is so, let's call Xn the nth bit of X in binary representation. Now consider that each parity bit is tied to a bit of X: parity1 -> X1, parity2 -> X2, parity4 -> X3, parity8 -> X4 and so on - for programmers: they are the respective AND masks -. By construction, the failed bit makes fail only the parity bits which correspond to the 1s in X, so each bit of X is 1 if the corresponding parity is wrong and 0 if it is correct.

Note that the longer the string, the higher the throughput n/m and the lower the probability that no more than one bit fails. So the string to be sent should be broken into blocks whose length depends on the transmission channel quality (the cleaner the channel, the bigger the block). Also, unless it's guaranteed that at most one bit per block fails, a checksum or some other form of data integrity check should be added.
<br></font>

<b><font color=#B45F04 size=6>Alphanumeric Codes</b></font><font size=4>
The binary codes that can be used to represent all the letters of the alphabet, numbers and mathematical symbols, punctuation marks, are known as alphanumeric codes or character codes. These codes enable us to interface the input-output devices like the keyboard, printers, video displays with the computer.
<br></font>

<b><font color=#B45F04 size=6>ASCII Code</b></font><font size=4>
ASCII stands for American Standard Code for Information Interchange. It has become a world standard alphanumeric code for microcomputers and computers. It is a 7-bit code representing 27 = 128 different characters. These characters represent 26 upper case letters (A to Z), 26 lowercase letters (a to z), 10 numbers (0 to 9), 33 special characters and symbols and 33 control characters.
The 7-bit code is divided into two portions, The leftmost 3 bits portion is called zone bits and the 4-bit portion on the right is called numeric bits.
An 8-bit version of ASCII code is known as USACC-II 8 or ASCII-8. The 8-bit version can represent a maximum of 256 characters.
<br></font>

<b><font color=#B45F04 size=6>EBCDIC Code</b></font><font size=4>
EBCDIC stands for Extended Binary Coded Decimal Interchange. It is mainly used with large computer systems like mainframes. EBCDIC is an 8-bit code and thus accomodates up to 256 characters. An EBCDIC code is divided into two portions: 4 zone bits (on the left) and 4 numeric bits (on the right).
<br></font>




</body>
</html>